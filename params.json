{"name":"Undirected graph","tagline":"A simple (probably incomplete) implementation of an undirected graph in c++ using the stl.","body":"# undirected_graph\r\n\r\nDuring my work on a group assignment I needed a graph container to store objects and their connections.\r\nI knew that there is an implementation in the boost library but I wanted to play a little bit with\r\ntemplates and see how far I can get with it.\r\n\r\nThe feature set of the container is limited but definitely enough for simple applications. Furthermore my implementation may be quite far from optimal performance because it uses (among others) `std::unordered_map` containers as its\r\nunderlying data structures. Again I didn't want to create a perfectly optimized implementation but to\r\nlearn and have fun coding. If you have ideas for improvements or find bugs, feel free to notify me about them!\r\nWhen I have time I'll check whether using google's `dense_hash_map` results in better performance.\r\n\r\nThe project is licensed under the GNU GPL v2 license. Have a look into the LICENSE file for more information.\r\n\r\n## Quickstart\r\n\r\nTo start using the `undirect_graph` simply include the `.h` files in your project and instantiate the graph\r\nwith the corresponding template arguments:\r\n```c++\r\ntemplate <typename vertex_data_type_arg, typename vertex_id_type_arg, \r\n\t\t  typename edge_data_type_arg, typename edge_id_type_arg>\r\nclass undirected_graph;\r\n```\r\nThe `edge_id_type` has to meet certain criteria, for an easy start use the supplied `undirected_pair<T>` where `T`\r\nwould be the `vertex_id_type` of the graph.\r\n```c++\r\ntemplate <typename T>\r\nclass undirected_pair;\r\n```\r\nMost of the time you can use `int` or `size_t` as the `vertex_id_type` and `undirected_pair<int>` or respectively\r\n`undirected_pair<size_t>` as the `edge_id_type`. If you want to use your own id types (maybe you already have ids\r\nfor the objects in your code) make sure to check the requirements some paragraphs below.\r\n\r\n## What does it do?\r\n\r\nFor a full list of features have in look in the documentation which will be added soon.\r\n\r\nThe graph allows to store vertex data types with unique ids which are connected by edge data objects which\r\nhave in turn unique ids. Naturally the graph is implemented using templates and therefore every data type\r\nis supported.\r\n\r\nIn most operations the graph behaves similar to the `std::map` container because (a) it is built using maps and\r\n(b) it's what you're probably used to after working with stl containers. The only difference is that most methods\r\nhave an appended `_vertex` or `_edge` to indicate on which object the method works.\r\n\r\nSome example code:\r\n```c++\r\ntypedef undirected_graph<std::string, size_t, double, undirected_pair<size_t>> graph_type;\r\ngraph_type graph;\r\n\r\ngraph.insert_vertex(1, \"Hello world!\");\r\ngraph.insert_vertex(2, \"Some more text.\");\r\ngraph.insert_vertex(3, \"Hi\");\r\n\r\ngraph.insert_edge(1, 2, 44.12);\r\ngraph.insert_edge(2, 3, 22.34);\r\n\r\nfor(auto it = graph.begin_edges(); it != graph.end_edges(); ++it) {\r\n\t\tstd::cout << \"Connection\" << it->first.a << \"to\" << it->first.b \r\n\t\t\t\t  << \"with value:\" << it->second << std::endl;\r\n}\r\n\r\ngraph.erase_vertex(2);\r\n```\r\nMore example code will be added to the repository soon.\r\n\r\n## What does this project supply?\r\n\r\nThe project consist mainly of three parts:\r\n- `undirected_graph` the main component of the graph I've been writing about this whole document.\r\n- `undirected_pair` a simple data type which behaves similar to a `std::pair` except for the fact that it is just\r\nfor one data type, pair(a,b) and pair(b,a) compare as equal and it's sortable. The sorting order\r\nis determined by the smaller and bigger elements of the pairs. It's a simple data type to use for the\r\nedge ids in the graph.\r\n- `graph_search_iterator` is an abstract class that provides an interface for graph traversal iterators.\r\nTwo subclasses are supplied: a breadth-first and a depth-first iterator.\r\n\r\n## Requirements for the data types\r\n\r\nThere are no requirements or restrictions on the datatypes supplied as `vertex_data_type` or `edge_data_type`.\r\nHowever there are some requirements for the id types. \r\n\r\n`vertex_id_type` basically has to fulfil the same requirements as for an `unordered_set` and a `std::map`. Namely:\r\n- Equality operator `==`\r\n- Strict weak ordering operator `<`\r\n- Specialized `std::hash` functor (see http://stackoverflow.com/a/17017281/929037)\r\n\r\nThe same applies to the `edge_id_type` with some more restrictions:\r\n- Additional constructor with the signature `edge_id(vertex_id a, vertex_id b)`\r\n- Equality operator where `edge_id(a,b) == edge_id(b,a)` (this also affects the `<`-operator and hash functor, see below)\r\n- Access to the two connected `vertex_id`s via a public `a` and `b` member\r\n\r\nFor a datatype that implements all these requirements have a look at the `undirected_pair`. Nevertheless here are the \r\naxioms for the `<`-operator of the `edge_id_type`: \r\n```\r\nLet a, b, c, d be of type vertex_id and idA(a,b), idB(c,d) be of type edge_id. Then:\r\n1. min(a,b) < min(c,d) then: (idA < idB)\r\n2. If not 1 and min(c,d) < min(a,b) then: (idB < idA)\r\n3. If not 1 and not 2 and max(a,b) < max(c,d) then: (idA < idB)\r\n4. If not 1 and not 2 and not 3 then: not (idA < idB)\r\n```\r\n\r\n## Todo\r\n\r\n- Implement `erase` by iterator functions\r\n- Implement unit tests\r\n- Make sure that it works with google sparsehash containers (`dense_hash_map` and `dense_hash_set`, see https://code.google.com/p/sparsehash/)\r\n- Check whether the interface is ok when using `unique_ptr` as data objects\r\n- Check whether there is a performance difference btween storing `forward_list` directly in the adjacency\r\nmap vs. storing pointers to the lists in it\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}