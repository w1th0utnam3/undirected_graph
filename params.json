{"name":"Undirected graph","tagline":"A simple (probably incomplete) implementation of an undirected graph in c++ using the stl.","body":"# undirected_graph\r\nA simple (probably incomplete) implementation of an undirected graph in c++\r\nusing the stl.\r\n\r\nDuring my work on a group assignment I needed a graph container to store objects\r\nand their connections. I knew that there is an implementation in the boost\r\nlibrary (http://www.boost.org/doc/libs/1_58_0/libs/graph/doc/) but I wanted to\r\nplay a little bit with templates and see how far I can get with it.\r\n\r\nThe feature set of the container is limited but definitely enough for simple\r\napplications. Furthermore my implementation may be quite far from optimal\r\nperformance because it uses (among others) `std::unordered_map` containers as\r\nits underlying data structures. Again I didn't want to create a perfectly\r\noptimized implementation but to learn and have fun coding. If you have ideas for\r\nimprovements or find bugs, feel free to notify me about them! When I have time\r\nI'll check whether using google's `dense_hash_map` results in better performance.\r\n\r\nThe project is licensed under the GNU GPL v2 license. Have a look into the\r\nLICENSE file for more information.\r\n\r\n## Quickstart\r\n\r\nTo start using the `undirect_graph` simply include the `.h` files in your\r\nproject and instantiate the graph with the corresponding template arguments:\r\n```c++\r\ntemplate <class Key_vertex, class T_vertex,\r\n\t\t  class Key_edge, class T_edge>\r\nclass undirected_graph;\r\n```\r\nThe `Key_edge` type has to meet certain criteria, for an easy start use the\r\nsupplied `undirected_pair<T>` where `T` would be the `Key_vertex` type of the\r\ngraph.\r\n```c++\r\ntemplate <typename T>\r\nclass undirected_pair;\r\n```\r\nMost of the time you can use `int` or `size_t` as the `Key_vertex` type and\r\n`undirected_pair<int>` or respectively `undirected_pair<size_t>` as the\r\n`Key_edge` type. If you want to use your own id types (maybe you already have\r\nids for the objects in your code) make sure to check the requirements some\r\nparagraphs below.\r\n\r\n## Features\r\n\r\nThe graph allows to store vertex data types with unique ids which are connected\r\nby edge data objects which have in turn unique ids. Naturally the graph is\r\nimplemented using templates and therefore every data type is supported.\r\n\r\nIn most operations the graph behaves similar to the `std::map` container because\r\n(a) it is built using maps and (b) it's what you're probably used to after\r\nworking with stl containers. The only difference is that most methods have an\r\nappended `_vertex` or `_edge` to indicate on which objects the method works.\r\n\r\nIt is possible to:\r\n - add vertex data with a unique id\r\n - add edge data by specifying two vertex ids that aren't already connected\r\n - access the data by reference using the corresponding id\r\n - remove vertices and egdes by id\r\n - iterate through all vertices or edges (unordered)\r\n - iterate through all adjacent vertices of a vertex with a specified id\r\n - iterate through the graph vertices by using an breadth- or depth-first search\r\n   iterator\r\n\r\nSome example code:\r\n```c++\r\ntypedef undirected_graph<size_t, std::string, undirected_pair<size_t>, double> graph_type;\r\ngraph_type graph;\r\n\r\n// Build graph\r\ngraph.insert_vertex(1, \"Hello world!\");\r\ngraph.insert_vertex(2, \"Some more text.\");\r\ngraph.insert_vertex(3, \"Hi\");\r\ngraph.insert_edge(1, 2, 44.12);\r\ngraph.insert_edge(2, 3, 22.34);\r\n\r\n// Print edge data\r\nfor(auto it = graph.begin_edges(); it != graph.end_edges(); ++it) {\r\n\t\tstd::cout << \"Connection\" << it->first.a << \"to\" << it->first.b\r\n\t\t\t\t  << \"with value:\" << it->second << std::endl;\r\n}\r\n\r\nbreadth_first_iterator<graph_type> bfs(graph, graph.find_vertex(1));\r\n// Iterate through the graph and print the strings\r\nwhile(!bfs.end()) {\r\n\tstd::cout << bfs.next()->second << std::endl\r\n}\r\n\r\n// Remove a vertex and its edge(s)\r\ngraph.erase_vertex(2);\r\n```\r\nYou can find more example code in the `main.cpp` in the test subfolder.\r\n\r\n## What does this project contain?\r\n\r\nThe project consist mainly of three parts:\r\n- `undirected_graph` the main component of the graph I've been writing about\r\n  this whole document.\r\n- `undirected_pair` a simple data type which behaves similar to a `std::pair`\r\n  except for the fact that it is just for one data type, pair(a,b) and pair(b,a)\r\n  compare as equal and it's sortable. The sorting order is determined by the\r\n  smaller and bigger elements of the pairs. It's a simple data type to use for\r\n\tthe edge ids in the graph.\r\n- `graph_search_iterator` is an abstract class that provides an interface for\r\n  graph traversal iterators. Two subclasses are supplied: a breadth-first and a\r\n  depth-first iterator.\r\n\r\n## Requirements for the data types\r\n\r\nThere are no requirements or restrictions on the data types supplied as\r\n`T_vertex` or `T_edge`. However there are some requirements for\r\nthe id types.\r\n\r\n`Key_vertex` basically has to fulfil the same requirements as a key for an\r\n`std::unordered_set` and a `std::map`. Namely:\r\n- Equality operator `==`\r\n- Strict weak ordering operator `<`\r\n- Specialized `std::hash` functor (see http://stackoverflow.com/a/17017281/929037)\r\n\r\nThe same applies to the `Key_edge` with some more restrictions:\r\n- Additional constructor with the signature `edge_id(vertex_id a, vertex_id b)`\r\n- Equality operator where `edge_id(a,b) == edge_id(b,a)` (this also affects the\r\n\t`<`-operator and hash functor, see below)\r\n- Access to the two connected `vertex_id`s via a public `a` and `b` member\r\n\r\nFor a data type that implements all these requirements have a look at the\r\n`undirected_pair`. Nevertheless here are the axioms for the `<`-operator of the\r\n`Key_edge`:\r\n```\r\nLet a, b, c, d be of type vertex_id and idA(a,b), idB(c,d) be of type edge_id. Then:\r\n1. min(a,b) < min(c,d) then: (idA < idB)\r\n2. If not 1 and min(c,d) < min(a,b) then: (idB < idA)\r\n3. If not 1 and not 2 and max(a,b) < max(c,d) then: (idA < idB)\r\n4. If not 1 and not 2 and not 3 then: not (idA < idB)\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}